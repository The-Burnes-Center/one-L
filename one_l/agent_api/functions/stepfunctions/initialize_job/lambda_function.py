"""
Initialize job Lambda function.
Updates job status to 'processing' and passes context through the workflow.

Note: job_id is now generated by start_workflow Lambda (before Step Functions starts)
so that API can return job_id immediately to frontend for polling.
"""

import json
import boto3
import logging
import os
from datetime import datetime

logger = logging.getLogger()
logger.setLevel(logging.INFO)

dynamodb = boto3.resource('dynamodb')

def lambda_handler(event, context):
    """
    Initialize workflow processing for document review.
    
    The job_id and DynamoDB record are already created by start_workflow Lambda.
    This step updates the status to 'processing' and passes context to downstream steps.
    
    Args:
        event: Lambda event with job_id, timestamp, session_id, user_id, document_s3_key
        context: Lambda context
        
    Returns:
        Full context for downstream functions
    """
    try:
        # Get values from start_workflow (already in event)
        job_id = event.get('job_id')
        timestamp = event.get('timestamp')
        session_id = event.get('session_id')
        user_id = event.get('user_id')
        document_s3_key = event.get('document_s3_key')
        bucket_type = event.get('bucket_type', 'agent_processing')
        terms_profile = event.get('terms_profile', 'general')
        
        if not job_id or not session_id or not user_id:
            raise ValueError("job_id, session_id, and user_id are required")
        
        logger.info(f"Initializing workflow for job: {job_id}")
        
        # Update status to 'processing' in DynamoDB
        table_name = os.environ.get('ANALYSES_TABLE_NAME')
        if table_name and timestamp:
            table = dynamodb.Table(table_name)
            table.update_item(
                Key={
                    'analysis_id': job_id,
                    'timestamp': timestamp
                },
                UpdateExpression='SET #status = :status, updated_at = :updated',
                ExpressionAttributeNames={'#status': 'status'},
                ExpressionAttributeValues={
                    ':status': 'processing',
                    ':updated': datetime.utcnow().isoformat()
                }
            )
            logger.info(f"Job {job_id} status updated to 'processing'")
        
        # Return full context for downstream functions
        return {
            "job_id": job_id,
            "timestamp": timestamp,
            "session_id": session_id,
            "user_id": user_id,
            "document_s3_key": document_s3_key,
            "bucket_type": bucket_type,
            "terms_profile": terms_profile,
            "status": "processing"
        }
        
    except Exception as e:
        logger.error(f"Error initializing job: {e}")
        raise

